/*!
 * wordcloud2.js
 * http://timdream.org/wordcloud2.js/
 *
 * Copyright 2011 - 2013 Tim Chien
 * Released under the MIT license
 */

'use strict';

// setImmediate
if (!window.setImmediate) {
  window.setImmediate = (function setupSetImmediate() {
    return window.msSetImmediate ||
    window.webkitSetImmediate ||
    window.mozSetImmediate ||
    window.oSetImmediate ||
    (function setupSetZeroTimeout() {
      if (!window.postMessage || !window.addEventListener) {
        return null;
      }

      var callbacks = [undefined];
      var message = 'zero-timeout-message';

      // Like setTimeout, but only takes a function argument.  There's
      // no time argument (always zero) and no arguments (you have to
      // use a closure).
      var setZeroTimeout = function setZeroTimeout(callback) {
        var id = callbacks.length;
        callbacks.push(callback);
        window.postMessage(message + id.toString(36), '*');

        return id;
      };

      window.addEventListener('message', function setZeroTimeoutMessage(evt) {
        // Skipping checking event source, retarded IE confused this window
        // object with another in the presence of iframe
        if (typeof evt.data !== 'string' ||
            evt.data.substr(0, message.length) !== message/* ||
            evt.source !== window */) {
          return;
        }

        evt.stopImmediatePropagation();

        var id = parseInt(evt.data.substr(message.length), 36);
        if (!callbacks[id]) {
          return;
        }

        callbacks[id]();
        callbacks[id] = undefined;
      }, true);

      /* specify clearImmediate() here since we need the scope */
      window.clearImmediate = function clearZeroTimeout(id) {
        if (!callbacks[id]) {
          return;
        }

        callbacks[id] = undefined;
      };

      return setZeroTimeout;
    })() ||
    // fallback
    function setImmediateFallback(fn) {
      window.setTimeout(fn, 0);
    };
  })();
}

if (!window.clearImmediate) {
  window.clearImmediate = (function setupClearImmediate() {
    return window.msClearImmediate ||
    window.webkitClearImmediate ||
    window.mozClearImmediate ||
    window.oClearImmediate ||
    // "clearZeroTimeout" is implement on the previous block ||
    // fallback
    function clearImmediateFallback(timer) {
      window.clearTimeout(timer);
    };
  })();
}

(function(global) {

  // Check if WordCloud can run on this browser
  var isSupported = (function isSupported() {
    var canvas = document.createElement('canvas');
    if (!canvas || !canvas.getContext) {
      return false;
    }

    var ctx = canvas.getContext('2d');
    if (!ctx.getImageData) {
      return false;
    }
    if (!ctx.fillText) {
      return false;
    }

    if (!Array.prototype.some) {
      return false;
    }
    if (!Array.prototype.push) {
      return false;
    }

    return true;
  }());

  // Find out if the browser impose minium font size by
  // drawing small texts on a canvas and measure it's width.
  var minFontSize = (function getMinFontSize() {
    if (!isSupported) {
      return;
    }

    var ctx = document.createElement('canvas').getContext('2d');

    // start from 20
    var size = 20;

    // two sizes to measure
    var hanWidth, mWidth;

    while (size) {
      ctx.font = size.toString(10) + 'px sans-serif';
      if ((ctx.measureText('\uFF37').width === hanWidth) &&
          (ctx.measureText('m').width) === mWidth) {
        return (size + 1);
      }

      hanWidth = ctx.measureText('\uFF37').width;
      mWidth = ctx.measureText('m').width;

      size--;
    }

    return 0;
  })();

  // Based on http://jsfromhell.com/array/shuffle
  var shuffleArray = function shuffleArray(arr) {
    for (var j, x, i = arr.length; i;
      j = Math.floor(Math.random() * i),
      x = arr[--i], arr[i] = arr[j],
      arr[j] = x) {}
    return arr;
  };

  var WordCloud = function WordCloud(elements, options) {
    if (!isSupported) {
      return;
    }

    if (!Array.isArray(elements)) {
      elements = [elements];
    }

    elements.forEach(function(el, i) {
      if (typeof el === 'string') {
        elements[i] = document.getElementById(el);
        if (!elements[i]) {
          throw 'The element id specified is not found.';
        }
      } else if (!el.tagName && !el.appendChild) {
        throw 'You must pass valid HTML elements, or ID of the element.';
      }
    });

    /* Default values to be overwritten by options object */
    /* Default values to be overwritten by options object */
    var settings = {
      list: [],
      fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", ' +
                  '"Arial Unicode MS", "Droid Fallback Sans", sans-serif',
      fontWeight: 'normal',
      color: 'random-dark',
      minSize: 0, // 0 to disable
      weightFactor: 1,
      clearCanvas: true,
      backgroundColor: '#fff', // opaque white = rgba(255, 255, 255, 1)

      gridSize: 8,
      drawOutOfBound: false,
      shrinkToFit: false,
      origin: null,

      drawMask: false,
      maskColor: 'rgba(255,0,0,0.3)',
      maskGapWidth: 0.3,

      wait: 0,
      abortThreshold: 0, // disabled
      abort: function noop () {},

      minRotation: -Math.PI / 2,
      maxRotation: Math.PI / 2,
      rotationSteps: 2,

      shuffle: true,
      rotateRatio: 0.1,

      shape: 'circle',
      ellipticity: 0.65,

      classes: null,

      hover: null,
      click: null
    }

    if (options) {
      for (var key in options) {
        if (key in settings) {
          settings[key] = options[key];
        }
      }
    }

    /* Convert weightFactor into a function */
    if (typeof settings.weightFactor !== 'function') {
      var factor = settings.weightFactor;
      settings.weightFactor = function weightFactor(pt) {
        return pt * factor; //in px
      };
    }

    /* Convert shape into a function */
    if (typeof settings.shape !== 'function') {
      switch (settings.shape) {
        case 'circle':
        /* falls through */
        default:
          // 'circle' is the default and a shortcut in the code loop.
          settings.shape = 'circle';
          break;

        case 'cardioid':
          settings.shape = function shapeCardioid(theta) {
            return 1 - Math.sin(theta);
          };
          break;

        /*

        To work out an X-gon, one has to calculate "m",
        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))
        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28
        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29

        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))
        where t' equals to mod(t, 2PI/X);

        */
        case 'heart':
          settings.shape = function heart(theta) {
            var max = 256;
            var leng = [205,207,208,209,210,211,212,213,214,215,217,218,219,220,222,223,223,225,226,228,228,230,230,232,232,234,234,235,237,237,238,239,240,241,241,242,243,244,245,246,246,247,247,248,248,249,249,251,251,251,251,252,252,253,252,254,254,254,254,255,255,254,255,254,255,256,255,256,255,255,254,255,255,254,255,254,254,254,253,253,252,252,252,251,251,250,249,249,249,248,247,246,246,244,243,243,242,241,240,239,238,237,235,234,233,231,230,229,227,226,225,223,222,221,219,216,215,213,211,210,208,206,204,202,199,198,195,193,192,189,187,184,182,179,176,175,171,169,167,164,163,160,157,155,154,152,149,147,145,143,140,139,136,135,133,130,127,125,127,130,131,134,136,139,140,143,144,147,149,152,153,155,158,161,163,165,166,169,171,175,176,179,181,184,186,189,190,193,196,198,199,202,204,206,208,209,211,213,215,216,218,219,222,223,225,226,227,228,230,231,232,234,235,237,237,238,240,240,242,243,243,244,246,246,247,248,248,249,250,250,250,251,252,252,253,253,253,253,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,254,254,253,253,252,252,252,252,251,251,250,250,250,248,248,247,247,246,246,245,244,243,242,241,241,240,239,238,238,237,235,234,234,232,232,230,230,228,228,226,225,224,222,222,220,219,218,218,215,214,214,213,211,210,209,208,207,206,205,204,203,202,201,199,198,197,196,195,194,194,192,191,191,190,188,187,187,186,186,184,183,183,182,182,180,179,179,178,177,176,176,175,175,174,173,173,172,172,171,170,170,170,169,169,168,167,167,167,166,166,166,165,165,165,164,164,163,163,163,163,163,162,162,161,161,161,161,161,161,161,160,160,160,159,159,160,160,160,160,160,160,160,159,159,159,159,160,160,160,161,160,160,161,161,161,161,161,161,161,162,162,162,162,163,164,164,163,164,165,165,165,166,166,167,167,167,168,168,169,170,169,171,171,172,172,173,173,174,176,176,177,177,178,180,179,181,182,182,183,184,184,186,187,188,188,190,191,193,193,195,196,197,199,200,201,201,199,198,197,195,194,193,192,191,189,189,187,187,185,185,184,183,181,182,180,179,179,177,178,176,175,175,174,174,173,172,172,171,170,170,169,169,168,168,167,167,167,166,165,165,165,164,164,164,163,163,163,163,162,162,162,161,161,162,161,161,160,160,160,160,160,160,160,160,160,159,160,159,160,160,160,159,159,160,160,160,160,161,161,161,161,161,161,161,161,162,162,162,162,162,163,163,164,164,164,164,165,165,166,166,167,166,166,167,168,168,169,170,170,171,171,171,172,173,173,174,174,175,176,177,177,178,179,179,180,181,181,182,183,184,185,185,187,187,188,189,190,190,192,193,194,195,195,197,198,199,200,201,202,204,205,207];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'africa1':
          settings.shape = function africa1(theta) {
            var max = 797;
            var leng = [359,364,367,371,374,378,382,390,396,401,404,408,412,415,420,424,428,432,436,437,441,445,449,452,457,458,460,463,469,472,476,480,485,489,495,500,502,505,507,513,515,517,520,524,493,473,448,426,418,416,415,415,414,416,415,413,410,425,425,426,425,424,425,423,425,424,425,423,424,425,425,424,422,424,419,420,416,419,419,421,423,426,430,434,436,439,442,443,447,446,446,448,448,448,451,457,462,465,473,479,484,488,494,498,498,501,500,502,507,514,522,526,531,536,541,545,550,556,561,568,574,581,584,590,599,603,633,632,634,636,634,632,627,618,614,616,616,616,617,620,620,619,621,618,621,626,625,627,627,630,637,641,640,639,637,634,628,593,589,587,591,597,601,604,606,607,609,613,631,635,639,644,647,647,647,651,655,660,669,678,739,741,743,744,746,747,748,748,754,757,757,759,759,761,763,765,764,762,759,761,761,759,758,763,769,773,776,788,797,790,784,779,774,773,775,776,774,772,768,762,758,750,736,731,728,727,726,726,724,725,728,733,732,727,723,722,724,722,719,716,710,708,708,708,706,704,701,698,697,698,694,691,672,665,663,657,649,644,640,637,636,634,632,629,627,625,625,625,628,616,592,604,607,588,572,577,574,566,558,551,535,533,527,525,522,517,514,503,497,487,478,468,462,456,451,444,406,395,382,372,359,349,337,329,319,310,301,291,284,277,270,263,256,248,243,237,231,226,221,216,210,205,202,197,193,190,186,181,179,175,171,169,169,168,168,168,167,167,167,167,164,163,166,162,166,166,166,166,164,165,165,165,165,166,162,162,159,160,163,163,162,161,161,160,160,160,160,159,160,160,160,160,160,159,159,160,160,159,159,159,160,160,160,160,160,159,160,162,162,163,163,164,164,164,166,166,167,168,171,172,173,174,174,177,170,167,181,183,183,184,184,185,188,190,192,193,194,196,198,200,201,203,205,209,222,224,226,231,233,236,237,240,243,244,247,253,263,359,367,385,393,396,402,404,408,413,420,424,429,439,445,450,457,461,467,494,510,526,543,557,570,577,583,590,599,616,630,640,656,693,700,707,705,700,698,698,695,693,693,695,693,696,699,694,697,691,693,691,688,684,679,676,670,665,660,656,649,643,635,628,623,618,616,611,602,591,584,561,558,557,556,555,555,555,554,553,549,536,530,513,493,474,465,468,466,464,462,461,463,461,458,457,451,453,452,453,452,453,454,455,456,456,456,457,456,455,453,452,451,450,446,444,441,432,427,423,420,414,414,408,404,401,397,393,393,390,387,372,367,364,360,353,351,347,346,346,344,338,337,337,337,335,328,321,318,317,316,316,316,316,315,314,314,313,316,316,316,316,316,317,316,316,316,318,318,317,316,317,322,324,324,324,331,331,333,334,335,337,337,339,342,342,345,347,349,352,354,358,359];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'africa':
          settings.shape = function africa(theta) {
            var max = 829;
            var leng = [419,425,429,434,439,445,454,462,467,472,477,481,487,494,497,503,506,511,516,520,525,528,529,534,539,544,548,555,559,564,569,574,578,580,586,588,589,593,595,552,508,484,473,470,469,468,467,467,465,454,475,475,475,476,472,472,469,471,470,469,467,467,468,467,465,463,463,458,453,455,456,457,458,460,463,466,469,472,474,475,476,477,475,477,476,475,476,479,484,489,493,501,505,510,512,517,521,520,522,522,521,526,530,541,543,544,550,554,557,561,564,569,573,581,585,592,595,599,603,610,614,644,646,642,646,645,641,639,634,627,621,620,622,620,623,621,622,623,623,623,623,619,624,628,626,626,628,629,637,639,640,641,640,637,636,633,603,593,589,587,589,593,598,602,604,606,608,608,611,616,635,637,641,645,647,650,649,650,655,659,663,670,676,746,746,747,752,753,755,759,758,758,764,768,770,771,773,774,778,779,781,783,783,782,783,784,786,782,783,787,797,799,804,808,829,829,824,818,814,811,812,813,816,817,815,814,808,806,801,792,780,779,776,776,778,778,777,781,786,791,789,787,783,785,787,785,782,780,775,776,777,776,776,774,772,771,773,770,766,747,741,741,733,725,720,716,714,713,713,711,708,706,707,709,709,697,691,685,688,687,659,657,648,637,628,615,607,603,599,596,594,583,567,559,550,536,528,522,510,465,448,432,417,402,390,376,363,352,338,328,319,308,300,292,283,274,268,260,254,247,239,234,229,223,217,212,207,203,197,196,196,195,195,194,193,194,193,188,192,187,192,192,189,188,188,189,189,190,189,186,187,182,186,184,184,183,182,182,181,180,180,180,180,180,179,178,178,179,179,178,177,176,177,177,177,176,176,175,176,176,178,178,178,178,178,179,179,180,181,181,185,186,186,187,186,190,190,179,192,193,194,195,195,195,197,198,200,201,203,204,205,206,208,210,211,212,215,218,232,233,236,238,241,243,244,246,249,249,253,255,261,269,368,377,390,397,401,406,408,410,414,419,423,428,431,439,445,450,454,461,464,469,486,507,515,536,546,562,568,577,580,587,592,603,619,629,638,646,693,698,700,706,706,701,698,700,699,696,693,694,695,694,696,697,700,696,699,693,696,695,694,690,687,684,680,677,672,667,664,661,655,651,644,637,632,629,627,625,620,612,604,596,575,571,570,569,570,570,571,572,572,570,567,557,550,535,524,497,491,488,488,487,485,484,484,486,485,483,482,481,480,479,480,480,482,483,485,487,490,489,490,491,491,490,488,488,488,483,485,483,471,470,464,462,454,456,450,447,443,438,436,435,432,431,413,408,405,401,396,391,389,388,387,382,380,381,381,379,371,363,361,360,360,361,361,360,359,360,359,362,363,363,364,365,364,364,366,367,367,366,367,374,375,379,379,385,386,389,391,392,394,397,399,401,405,409,412,415,419];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'blob1':
          settings.shape = function blob1(theta) {
            var max = 384;
            var leng = [343,339,335,330,324,318,312,306,300,297,291,288,285,283,280,280,279,280,281,282,283,286,287,290,293,296,300,302,305,309,315,319,323,328,334,339,342,348,353,356,360,364,366,369,371,374,376,376,378,380,381,382,383,383,383,384,383,383,381,380,378,375,371,367,361,256,247,244,241,240,237,236,235,233,232,232,232,231,231,231,232,232,233,234,236,237,240,245,249,255,267,281,293,302,308,312,315,316,319,320,320,321,322,322,322,321,320,319,316,234,228,225,223,222,220,219,218,218,218,218,219,220,221,224,227,231,274,290,296,300,305,307,309,310,312,313,314,315,316,317,317,318,318,319,318,319,318,318,317,316,314,313,310,308,304,300,294,285,248,234,226,220,216,212,209,206,203,201,201,199,197,195,195,194,194,194,193,193,194,194,195,195,196,196,197,197,198,198,200,201,202,203,205,207,209,212,214,217,220,225,229,238,249,265,284,294,297,301,304,306,308,309,310,311,312,313,313,313,314,313,312,311,310,309,307,305,303,301,297,295,292,287,284,281,277,274,270,267,263,261,257,255,253,250,248,246,244,242,240,238,238,236,234,234,233,232,232,231,231,231,231,232,232,233,235,237,239,242,246,252,262,286,332,339,345,348,352,355,358,360,361,363,364,366,367,368,369,370,371,371,371,371,372,372,372,372,372,371,371,371,369,369,368,367,366,365,363,361,360,358,356,354,351,348,345,343,339,336,333,330,326,324,322,321,319,317,317,316,315,314,313,313,313,313,314,313,314,315,314,315,316,317,318,319,320,322,323,324,326,327,329,332,334,338,340,343,345,349,352,355,357,360,363,365,367,369,371,372,374,374,376,376,376,376,376,376,376,375,374,374,372,372,371,368,367,364,361,357,353,349,344,338,333,325,319,313,308,303,301,299,298,297,297,298,298,299,301,302,304,306,307,309,311,312,315,316,318,319,321,322,323,323,323,323,324,324,323,323,322,322,320,319,318,315,314,311,308,305,302,298,294,290,285,275,266,257,250,244,239,234,230,226,225,221,219,216,215,214,211,210,210,209,208,208,208,208,208,209,209,210,211,212,213,215,218,221,227,253,301,306,311,313,315,318,318,320,320,320,320,321,320,320,320,319,319,317,315,314,312,309,306,303,300,296,292,289,284,279,275,271,264,260,255,251,248,243,240,237,233,230,228,226,224,222,221,220,218,218,217,217,216,216,216,217,217,217,218,219,220,222,223,227,228,236,316,318,321,323,325,326,327,327,328,328,328,328,328,327,326,325,323,322,319,317,313,308,302,298,291,285,280,276,272,269,268,268,268,268,268,269,269,269,270,271,272,273,275,278,288,297,307,318,329,341,345,348,351,353,356,358,360,362,363,364,365,367,368,369,369,369,370,370,370,370,369,370,369,368,367,366,366,363,362,360,358,355,353,349,346];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'box':
          settings.shape = function shapeBox(theta) {
            var max = 368;
            var leng = [260,261,261,261,261,261,261,261,261,262,262,262,262,263,263,263,264,264,265,265,266,266,267,268,268,269,270,270,271,272,273,274,274,275,276,277,278,279,281,282,283,284,285,287,288,289,291,292,294,295,297,299,300,302,304,306,308,310,312,314,316,318,320,323,325,327,330,332,335,338,341,344,347,350,353,356,360,363,367,366,362,358,355,352,349,346,343,340,337,334,331,329,326,324,321,319,317,315,313,310,308,307,305,303,301,299,298,296,294,293,291,290,288,287,286,284,283,282,281,280,278,277,276,275,274,273,273,272,271,270,269,269,268,267,267,266,265,265,264,264,263,263,262,262,262,261,261,261,261,260,260,260,260,260,260,260,260,260,260,260,260,260,260,260,260,260,261,261,261,261,262,262,262,263,263,264,264,265,265,266,266,267,268,268,269,270,271,272,272,273,274,275,276,277,278,279,281,282,283,284,285,287,288,290,291,293,294,296,297,299,301,302,304,306,308,310,312,314,317,319,321,323,326,328,331,334,336,339,342,345,348,351,355,358,361,365,366,362,359,355,352,349,346,343,340,337,334,332,329,326,324,322,319,317,315,313,311,309,307,305,303,301,299,298,296,294,293,291,290,288,287,286,284,283,282,281,280,279,277,276,275,274,274,273,272,271,270,269,269,268,267,267,266,265,265,264,264,263,263,263,262,262,261,261,261,261,260,260,260,260,260,260,260,260,260,260,260,260,260,260,260,260,260,261,261,261,261,262,262,262,263,263,264,264,265,265,266,266,267,268,268,269,270,271,272,272,273,274,275,276,277,278,279,280,282,283,284,285,287,288,289,291,292,294,296,297,299,301,302,304,306,308,310,312,314,316,319,321,323,326,328,331,333,336,339,342,345,348,351,354,358,361,365,368,364,360,357,354,351,347,344,341,339,336,333,330,328,325,323,321,318,316,314,312,310,308,306,304,302,301,299,297,296,294,293,291,290,288,287,286,284,283,282,281,280,279,278,277,276,275,274,273,272,271,270,270,269,268,268,267,266,266,265,265,264,264,264,263,263,262,262,262,262,261,261,261,261,261,261,261,261,261,261,261,261,261,261,261,261,261,262,262,262,262,263,263,263,264,264,265,265,266,266,267,267,268,269,269,270,271,272,273,273,274,275,276,277,278,279,280,281,283,284,285,286,288,289,290,292,293,295,297,298,300,302,303,305,307,309,311,313,315,317,320,322,324,327,329,332,335,337,340,343,346,349,352,355,359,362,366,368,364,361,357,354,351,348,345,342,339,336,333,331,328,326,323,321,319,316,314,312,310,308,306,304,303,301,299,297,296,294,293,291,290,288,287,286,284,283,282,281,280,279,278,277,276,275,274,273,272,271,271,270,269,268,268,267,267,266,265,265,264,264,264,263,263,262,262,262,262,261,261,261,261,261,261,261,261,262];
            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'trapezoid':
          settings.shape = function trapezoid(theta) {
            var max = 245;
            var leng = [169,169,169,168,167,167,166,166,165,164,164,163,163,163,162,162,162,161,161,160,161,160,160,160,159,159,159,159,159,159,159,158,159,158,159,158,158,158,159,158,158,159,158,159,159,158,159,159,160,159,160,160,161,161,160,161,161,162,162,162,163,163,164,164,164,165,165,167,167,167,168,168,168,169,170,170,169,170,170,170,170,169,170,170,169,169,168,168,168,168,167,167,165,165,164,163,162,161,160,159,158,157,156,155,154,153,152,151,150,150,149,148,147,147,146,145,145,144,143,143,142,142,141,141,140,140,139,139,138,138,138,137,137,136,136,136,136,135,135,135,134,134,134,134,134,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,134,134,134,134,134,135,135,135,135,136,136,136,137,137,137,138,138,139,139,140,140,141,141,142,142,143,143,144,144,145,146,146,147,148,149,149,150,151,152,153,154,154,155,156,157,158,159,161,162,163,164,165,166,168,168,169,169,170,171,171,171,172,172,172,172,172,173,173,173,172,173,173,172,172,171,171,171,169,169,169,168,168,167,167,166,166,166,165,165,164,164,163,163,163,163,163,162,162,161,162,162,161,162,161,161,161,161,162,161,161,161,161,161,161,161,161,161,161,162,162,162,162,162,162,163,162,163,164,164,164,164,165,165,166,166,166,167,167,168,169,169,170,171,171,172,172,173,174,174,175,176,176,177,178,178,180,181,181,182,184,185,185,186,188,189,190,191,193,193,194,196,198,199,201,202,203,205,207,208,210,212,214,216,218,220,222,224,226,228,230,234,236,238,241,242,243,244,244,244,244,243,243,241,239,236,232,229,226,223,220,217,214,211,209,206,204,202,199,197,195,193,191,189,187,185,183,182,180,178,177,175,174,172,171,170,168,167,166,164,163,162,161,160,159,158,157,156,155,154,153,152,151,150,150,149,148,147,147,146,145,145,144,143,143,142,142,141,141,140,140,139,139,138,138,138,137,137,137,136,136,136,135,135,135,135,134,134,134,134,134,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,134,134,134,134,134,135,135,135,135,136,136,136,137,137,137,138,138,139,139,140,140,140,141,141,142,143,143,144,144,145,146,146,147,148,148,149,150,151,152,153,153,154,155,156,157,158,159,160,161,163,164,165,166,168,169,170,172,173,175,176,178,179,181,183,184,186,188,190,192,194,196,198,200,203,205,208,210,213,216,218,221,224,227,231,234,237,239,241,243,244,245,245,244,244,243,241,239,237,234,232,229,226,224,222,220,218,216,214,212,211,209,207,205,203,202,200,198,197,195,194,193,192,190,189,187,186,186,184,183,182,181,180,179,179,177,176,175,175,174,174,173,172,171,171,171];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'rocket':
          settings.shape = function rocket(theta){
            var max = 147;
            var leng = [28,29,30,31,29,30,31,29,30,31,30,29,31,30,28,29,31,29,28,30,30,28,29,30,29,28,31,29,30,31,30,29,31,30,29,32,31,30,32,31,30,32,31,33,30,32,31,33,32,31,33,32,34,33,35,32,33,34,34,35,33,34,36,35,35,36,35,37,36,37,38,36,36,37,38,36,37,38,39,40,39,41,39,40,41,41,42,41,42,43,44,45,45,46,45,46,47,48,49,50,51,50,51,52,52,53,53,54,55,56,57,58,59,60,91,93,95,96,97,99,99,101,101,103,104,105,107,108,108,110,112,112,112,114,115,115,116,118,119,119,120,120,121,122,123,123,124,124,125,125,126,126,126,126,126,126,126,126,126,126,126,125,124,124,123,123,122,121,120,119,118,118,117,116,115,113,113,112,110,110,108,108,106,105,104,101,101,100,98,97,55,54,55,54,52,51,50,48,47,46,45,44,43,42,44,41,40,39,38,38,37,38,36,35,37,34,35,33,33,32,33,31,34,32,30,31,32,32,30,31,31,29,29,30,28,29,30,27,29,28,27,29,26,27,28,25,27,26,25,27,24,26,28,25,26,24,26,23,24,25,24,26,23,25,23,22,24,23,25,24,22,25,23,21,22,23,23,21,24,22,25,23,21,24,21,22,20,21,22,23,24,20,21,22,23,20,21,22,23,24,20,21,22,23,24,20,21,22,23,24,20,21,22,23,24,20,21,22,23,20,21,22,23,22,20,21,23,23,21,22,24,23,22,21,24,24,23,22,21,24,23,22,21,24,23,25,22,24,25,23,22,24,25,23,25,22,24,26,23,25,24,26,23,25,26,24,26,25,27,24,26,27,25,28,26,27,25,28,26,29,27,27,28,29,27,29,28,30,29,29,30,31,29,31,30,31,31,32,33,31,34,32,33,34,34,35,35,36,35,37,38,38,39,40,41,42,43,43,44,45,45,46,47,48,49,50,51,52,52,53,54,56,57,58,60,64,66,68,70,72,74,77,79,82,85,92,96,99,104,108,144,143,143,143,143,142,142,142,142,142,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,142,142,142,142,143,143,143,143,144,144,144,145,145,145,146,146,147,147,112,108,105,99,96,94,91,89,87,82,80,78,77,75,73,72,70,69,68,67,63,62,61,60,59,58,57,56,55,56,54,53,52,53,51,50,51,49,48,46,46,45,46,44,44,43,44,42,43,41,42,41,40,41,41,39,39,40,38,39,40,37,37,38,36,37,36,38,35,36,36,35,37,34,35,36,34,32,33,34,32,33,35,31,32,31,32,33,31,33,32,30,31,32,30,31,32,30,31,32,33,29,30,29,30,31,32,29,30,31,29,30,31,29,30,31,32,29,30,31,29,30,31,32,30,31,32];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'mushroom':
          settings.shape = function mushroom(theta){
            var max = 142;
            var leng = [29,30,31,32,30,31,32,30,31,32,30,31,32,30,31,32,31,30,32,86,86,87,88,89,89,90,91,91,91,92,93,93,93,94,94,94,95,95,94,95,95,95,95,95,96,96,95,96,96,96,96,96,96,97,97,97,97,97,98,97,98,97,98,99,98,99,99,99,100,99,100,101,101,101,101,102,102,103,103,104,104,104,105,105,106,106,105,107,106,108,107,107,108,108,108,109,109,109,110,111,111,111,111,111,112,112,112,112,113,113,114,113,114,114,114,115,115,115,115,115,115,115,115,115,115,114,114,114,113,113,113,112,112,112,111,111,111,111,111,110,110,110,110,110,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,110,110,110,110,110,110,111,111,111,111,112,112,112,113,113,113,114,114,114,115,114,114,115,114,115,114,115,114,114,114,113,114,113,113,112,112,112,112,112,112,111,111,110,110,109,109,109,110,108,108,108,107,107,107,106,106,105,105,105,105,104,104,103,103,102,102,101,102,101,101,100,99,100,99,99,100,99,98,99,98,97,98,97,97,97,96,96,96,96,96,96,96,96,95,95,95,95,96,95,96,95,95,94,94,94,94,94,94,93,93,93,92,92,92,91,90,90,90,89,88,88,87,86,28,29,30,28,29,30,31,28,29,30,28,29,30,31,28,29,30,28,29,30,31,28,29,30,28,29,30,29,28,30,30,28,29,31,28,29,30,29,28,30,30,28,29,30,29,31,31,30,32,31,30,32,31,33,30,32,31,32,32,31,33,32,31,33,32,34,33,35,32,34,33,34,35,33,35,34,35,36,34,36,35,36,37,35,38,39,37,38,39,39,40,39,41,40,41,41,42,41,42,43,43,44,43,44,45,46,46,47,46,49,49,50,51,52,53,54,53,54,55,56,57,58,59,61,63,64,65,66,67,68,70,71,73,77,78,80,82,84,86,91,93,95,98,101,107,110,113,117,124,129,137,140,140,140,139,139,139,138,138,138,138,137,137,137,137,137,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,137,137,137,137,137,138,138,138,138,139,139,139,140,140,141,141,141,142,138,131,127,120,117,114,108,105,103,98,95,93,89,87,85,83,82,80,76,75,74,72,71,70,67,66,65,64,63,62,61,60,57,58,56,55,54,54,53,52,53,51,51,50,48,49,47,48,46,46,45,46,44,45,44,43,44,42,43,42,41,40,39,40,40,41,38,38,39,39,37,37,38,38,36,37,36,37,38,35,36,35,36,37,33,34,34,35,33,34,35,33,33,32,33,34,32,33,34,32,33,34,31,32,33,31,32,33,31,32,33,31,32,33,31,32,33,30,31,32,30,31,32,33,31,32,33];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'dookie':
          settings.shape = function shapeDookie(theta){
          var max = 1254;
          var leng = [687,680,675,668,663,655,649,642,634,623,619,608,605,596,587,582,582,579,575,574,573,572,573,575,576,577,579,581,582,582,584,585,587,589,590,590,590,593,595,597,596,597,600,599,601,601,601,602,603,601,603,602,603,601,600,600,600,599,596,598,596,594,593,591,589,588,583,582,578,579,575,573,571,568,566,561,560,558,555,554,552,546,545,544,542,540,539,539,541,544,547,550,554,562,569,581,589,594,603,612,619,624,630,639,642,650,654,662,666,672,676,683,684,691,694,700,704,708,711,717,723,727,730,736,742,745,752,756,758,764,772,776,780,786,791,796,800,807,812,817,823,829,834,839,844,850,857,860,867,871,877,882,888,894,898,904,910,914,921,925,929,933,940,945,950,954,957,964,967,972,979,982,985,991,993,998,1002,1004,1006,1009,1011,1008,1005,999,992,870,848,837,824,816,805,797,788,780,775,766,758,749,743,737,728,721,711,706,694,691,678,673,666,654,648,642,634,631,625,622,619,617,616,616,615,615,616,616,618,618,620,620,620,623,622,623,624,625,626,627,626,626,627,628,629,630,629,629,629,630,630,628,629,630,629,629,628,629,629,626,626,625,624,623,622,622,619,620,618,617,615,614,610,610,609,608,606,603,601,599,598,596,596,594,592,590,588,586,584,582,578,577,573,572,569,568,566,565,564,563,563,564,565,568,570,573,578,584,591,600,609,615,624,632,637,646,650,659,664,669,675,682,689,693,699,704,711,714,719,724,730,733,737,740,745,748,750,754,757,759,763,766,769,771,773,775,777,780,782,785,787,790,791,794,795,796,799,802,803,809,813,822,843,889,940,977,1008,1030,1049,1068,1084,1098,1112,1122,1134,1145,1152,1162,1170,1178,1186,1192,1201,1206,1213,1219,1224,1228,1232,1236,1239,1243,1246,1248,1250,1253,1254,1254,1253,1252,1253,1252,1250,1247,1244,1241,1236,1231,1228,1221,1214,1207,1198,1190,1181,1173,1165,1157,1147,1138,1128,1122,1113,1103,1094,1086,1080,1074,1066,1059,1054,1046,1041,1034,1028,1021,1017,1013,1007,1001,995,991,988,981,978,973,970,965,962,959,957,954,952,950,950,948,946,946,948,946,944,943,942,943,943,942,944,943,942,943,943,944,946,946,946,948,948,950,952,952,955,955,958,961,964,965,966,969,972,976,977,979,984,988,990,992,996,1000,1004,1007,1009,1014,1015,1017,1020,1024,1027,1030,1033,1037,1041,1045,1049,1051,1055,1059,1062,1066,1071,1074,1079,1084,1090,1093,1099,1100,1106,1112,1116,1121,1125,1132,1137,1138,1146,1151,1154,1160,1163,1169,1173,1180,1180,1187,1191,1193,1198,1202,1207,1208,1211,1215,1218,1219,1220,1222,1221,1222,1222,1221,1221,1219,1216,1214,1210,1206,1202,1196,1190,1184,1178,1170,1164,1156,1146,1136,1129,1116,1107,1096,1081,1072,1053,1037,1017,998,973,936,854,830,821,817,814,811,810,809,808,806,805,803,802,799,797,799,794,794,792,790,786,782,780,776,774,773,768,765,764,758,756,751,748,742,739,734,729,725,721,716,709,706,700,695,689];

          return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'poop':
          settings.shape = function shapeShit(theta) {
            var max = 1360;
            var leng = [797,790,779,771,763,752,745,734,723,712,703,692,679,674,673,668,664,662,660,661,663,664,666,667,669,668,670,672,674,674,674,676,676,678,680,679,679,680,679,680,680,679,680,678,679,678,676,675,674,673,670,665,666,664,659,658,655,652,649,643,641,635,635,629,627,622,618,616,610,608,603,601,598,593,590,586,583,580,580,577,577,578,580,581,584,590,597,607,615,622,627,635,643,649,654,658,666,669,676,679,686,690,694,695,700,705,707,712,715,718,720,725,728,733,736,739,742,746,750,754,757,760,765,769,770,774,781,785,787,793,796,800,805,808,813,817,822,826,832,834,839,843,846,852,857,862,867,871,874,879,883,888,893,896,900,906,910,914,921,923,929,933,936,940,946,950,953,958,963,966,972,976,979,985,987,992,996,998,1006,1009,1011,1013,1016,1019,1018,1018,1015,1011,1005,994,865,856,842,836,826,820,812,805,801,793,785,780,776,766,761,756,749,743,735,729,721,718,710,703,696,688,678,675,669,663,661,657,655,653,651,650,650,653,652,654,653,658,659,660,663,664,666,669,669,673,675,676,678,679,680,682,683,685,686,687,689,691,691,693,692,695,695,695,696,697,697,698,698,698,697,699,698,699,695,696,695,694,695,692,689,689,691,689,686,685,683,683,680,680,678,676,674,672,670,669,665,663,660,656,655,653,652,651,650,651,654,657,660,666,674,681,694,703,714,723,733,742,754,760,771,779,785,794,802,810,818,824,831,836,841,848,853,857,862,865,870,874,875,879,884,888,890,892,894,896,898,901,903,906,907,906,907,910,913,914,920,923,941,978,1045,1096,1132,1160,1185,1204,1222,1235,1248,1261,1273,1283,1290,1300,1308,1315,1321,1330,1333,1339,1342,1345,1350,1354,1356,1356,1359,1359,1358,1359,1360,1357,1358,1355,1352,1349,1347,1342,1338,1331,1326,1319,1312,1304,1296,1288,1277,1266,1256,1246,1236,1226,1216,1205,1193,1182,1174,1162,1152,1142,1134,1125,1118,1111,1102,1093,1087,1079,1073,1067,1057,1050,1045,1040,1035,1026,1021,1013,1009,1005,1001,995,989,986,980,977,974,971,968,965,962,959,957,956,954,952,952,950,950,948,947,945,943,945,944,945,945,944,944,943,944,943,945,946,946,946,946,948,948,950,952,952,955,955,956,958,961,964,966,967,968,974,975,979,980,982,986,990,994,996,998,1003,1007,1012,1015,1017,1020,1024,1027,1030,1033,1037,1041,1045,1049,1053,1057,1061,1066,1071,1073,1078,1083,1088,1092,1097,1103,1107,1113,1119,1126,1130,1137,1141,1146,1154,1161,1167,1172,1178,1187,1192,1196,1205,1212,1216,1224,1229,1236,1242,1249,1255,1261,1267,1274,1281,1286,1291,1298,1302,1309,1313,1317,1322,1323,1327,1330,1332,1334,1336,1333,1335,1331,1332,1328,1324,1320,1316,1310,1305,1298,1292,1284,1275,1264,1253,1244,1231,1218,1204,1185,1165,1145,1119,1082,1037,949,935,929,926,924,923,922,921,921,920,917,917,914,917,914,912,910,906,904,899,895,894,890,885,884,878,875,870,865,859,852,846,841,837,827,823,815,806,800];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'star8':
          settings.shape = function shapeStar8(theta) {
            var max = 431;
            var leng = [214,218,220,222,224,227,229,233,235,238,242,244,247,251,254,257,262,266,270,273,278,282,286,291,297,302,308,313,319,324,332,339,345,353,361,369,378,386,397,406,410,403,394,386,377,370,362,355,348,344,337,331,326,320,315,309,304,300,295,291,286,282,280,276,272,269,265,262,259,256,253,250,250,252,254,256,259,261,264,267,269,272,275,278,281,284,288,291,295,298,302,306,310,314,318,323,327,332,337,342,347,353,359,365,371,377,384,391,398,398,387,376,365,354,345,336,327,319,311,303,297,290,284,277,273,268,263,258,253,249,244,241,236,232,229,225,221,218,214,212,209,205,203,200,197,195,193,190,188,186,184,182,180,178,176,174,172,171,170,170,172,173,175,178,180,182,184,186,189,191,193,196,199,202,204,208,210,215,218,222,225,229,233,236,241,245,250,256,261,266,271,277,284,289,298,304,312,320,328,338,347,356,367,380,392,401,393,386,379,372,366,360,352,346,341,336,331,326,321,317,312,308,304,300,296,292,287,284,281,277,274,271,268,265,263,260,257,255,252,250,248,245,248,251,254,257,260,263,266,268,272,276,279,283,288,292,296,301,306,311,316,321,327,330,336,343,349,356,363,371,379,387,393,398,394,384,374,364,357,349,341,335,327,321,315,310,301,296,291,287,282,277,273,268,265,260,257,253,250,244,242,239,235,232,230,226,224,221,219,217,214,212,210,208,206,204,202,200,198,195,193,191,190,193,195,198,200,202,205,207,210,213,216,219,222,225,229,233,236,240,244,247,252,257,262,267,270,276,281,288,294,301,309,317,325,333,341,350,361,370,382,393,405,418,431,431,423,416,409,402,396,390,384,378,372,367,362,357,352,347,343,338,334,330,326,322,319,315,311,308,305,302,299,296,293,290,287,284,282,279,279,283,286,290,293,297,301,305,309,313,318,322,327,332,337,343,348,354,360,366,373,380,387,394,402,410,418,422,418,406,397,386,377,368,359,351,345,337,331,323,317,311,304,299,294,288,286,281,276,271,268,264,259,256,253,250,246,243,240,236,234,231,228,225,224,221,219,217,214,212,210,210,210,204,210,210,211,213,215,217,220,223,226,228,231,235,238,240,244,247,252,255,258,262,266,270,275,280,285,290,295,301,306,312,317,324,330,338,346,353,361,370,379,388,398,409,421,425,417,408,401,393,386,379,373,367,361,355,349,344,339,334,329,324,320,315,311,307,303,299,296,292,289,285,282,283,286,289,291,294,297,300,303,307,310,313,317,320,324,328,332,336,341,345,350,354,359,364,370,375,381,387,393,399,406,413,414,408,393,381,369,360,348,339,329,322,313,305,297,291,284,280,272,267,262,257,250,245,242,239,234,230,225,222,218,214,211,208,205,202,200,196,194,192,189,190,192,194,195,196,198,200,202,205,207,209,211,213,216];
            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;

        case 'hexagon':
          settings.shape = function shapeHexagon(theta) {
            var max = 213;
            var leng = [211,212,212,212,212,211,211,211,210,210,210,209,208,207,207,206,205,204,203,202,202,201,200,200,199,199,198,198,197,197,196,196,195,195,195,194,194,194,193,193,193,192,192,192,192,192,191,192,191,191,191,191,191,191,192,191,192,192,192,192,192,192,192,193,193,193,193,193,194,194,194,195,195,195,196,196,197,197,198,198,199,200,200,201,202,202,203,204,204,204,205,206,207,209,209,209,210,210,211,211,211,212,212,212,212,212,212,212,212,212,211,211,211,210,210,209,209,208,207,206,205,205,204,203,203,202,201,201,200,199,199,198,198,197,197,196,196,195,195,195,194,194,194,193,193,193,193,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,193,193,193,193,194,194,194,195,195,195,196,196,197,197,198,198,199,199,200,200,201,202,202,203,204,205,205,206,207,208,209,209,210,211,210,210,211,211,211,211,211,211,211,212,212,212,211,211,211,210,210,209,209,209,208,207,206,205,204,203,202,202,202,201,200,199,199,199,198,198,197,197,196,196,195,195,195,194,194,194,193,193,193,193,193,192,192,191,192,192,191,191,192,191,191,191,191,191,191,191,192,192,192,192,192,193,193,193,193,194,194,194,195,195,196,196,196,197,197,198,198,199,199,200,200,201,202,202,203,204,205,205,206,207,208,209,210,209,210,210,211,212,212,212,212,212,212,212,212,212,212,212,211,211,210,210,210,209,208,207,206,206,205,204,203,202,202,201,200,200,199,199,198,198,197,197,196,196,195,195,195,194,194,194,193,193,193,192,192,192,192,191,192,192,191,191,192,191,191,192,192,191,192,192,192,192,192,192,192,192,193,193,193,193,193,194,194,194,195,195,196,196,196,197,198,198,199,199,200,201,201,202,203,204,205,204,205,206,207,208,209,209,210,211,211,210,211,211,211,212,212,212,212,212,212,212,211,211,211,210,210,209,209,208,207,206,206,205,204,203,203,202,201,201,200,199,199,198,198,197,197,196,196,196,195,195,194,194,194,193,193,193,193,193,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,193,193,193,193,194,194,194,195,195,195,196,196,197,197,198,198,199,199,200,200,201,202,202,203,204,204,205,206,207,208,209,208,209,210,210,211,211,211,211,211,211,212,212,211,212,212,212,211,211,211,210,209,209,209,208,207,206,205,204,203,203,202,202,201,200,199,200,199,198,198,197,197,196,196,196,195,194,195,194,194,193,193,193,192,193,192,192,191,192,191,191,191,191,191,191,191,191,191,191,192,192,192,192,192,193,193,193,193,194,194,194,193,195,195,195,196,196,197,196,198,198,199,199,200,200,201,202,202,203,204,204,205,206,207,208,209,210,209,210,210,211,211,212,212,212,212,213];
            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'hyperbolic':
          settings.shape = function shapeHyperbolic(theta) {
            var max = 171;
            var leng = [160,146,141,133,128,125,122,119,116,113,111,109,108,106,105,102,100,100,98,96,95,95,94,92,92,90,89,89,88,87,86,86,85,84,83,84,82,82,81,81,80,80,79,79,78,78,78,77,77,76,77,75,76,75,75,75,75,74,74,75,74,73,74,73,73,72,73,72,73,72,72,73,72,73,72,73,72,73,72,73,72,73,72,73,72,73,72,73,72,73,72,73,72,73,73,73,74,74,74,75,74,75,75,75,75,76,76,77,77,77,77,78,78,79,79,79,80,81,82,81,82,83,84,83,85,86,86,87,87,89,90,91,91,92,93,95,95,96,98,100,100,102,104,106,107,108,110,113,116,119,122,125,129,133,137,144,154,160,151,145,136,131,127,124,121,118,115,112,110,109,107,105,103,101,100,99,97,96,96,94,92,92,90,90,90,88,87,86,86,86,84,84,83,82,83,81,81,80,80,79,79,78,78,78,77,78,76,77,75,76,75,75,75,75,74,74,73,74,73,74,73,73,72,73,72,73,72,73,72,71,72,71,71,72,71,72,71,72,71,72,71,72,71,72,73,72,73,72,73,72,73,73,73,73,73,74,75,73,74,75,75,75,76,75,76,76,76,77,78,77,78,79,78,79,80,81,80,81,82,83,83,83,85,85,85,86,87,89,89,90,91,91,93,95,94,96,98,99,100,102,104,105,107,107,110,113,115,118,121,124,127,131,138,146,152,162,152,141,136,131,128,124,121,118,115,113,110,109,108,106,104,102,101,100,98,97,96,95,93,93,93,91,90,89,88,88,87,86,85,85,85,83,83,83,82,81,81,81,80,79,79,79,78,78,77,78,77,77,76,76,75,76,76,75,75,75,74,74,75,74,75,74,74,73,74,73,74,73,74,73,74,73,73,73,73,74,73,74,73,73,73,73,74,74,74,74,74,74,75,76,74,75,75,75,76,75,76,77,76,77,78,77,78,77,79,79,80,79,80,81,81,82,82,83,83,84,84,84,85,86,87,87,88,89,90,92,92,92,94,95,96,98,99,99,101,103,105,105,106,109,111,114,116,120,123,126,129,133,137,141,152,171,0,151,144,135,131,127,125,121,119,115,113,110,110,109,108,107,106,103,101,100,99,97,97,95,93,94,93,92,91,92,90,89,90,87,87,85,86,84,84,83,83,82,81,82,80,80,79,80,79,79,78,78,77,78,76,77,76,75,75,74,75,74,74,75,74,75,74,74,74,74,73,74,75,74,75,74,74,75,74,75,73,74,73,74,74,75,74,74,74,75,74,75,75,75,76,75,76,75,76,77,76,76,77,76,78,78,78,78,79,78,80,80,80,81,81,82,82,83,83,84,85,85,86,86,87,88,89,89,90,91,92,92,94,95,96,99,99,99,101,104,106,107,108,109,111,113,116,118,120,123,126,131,137,142,146,152,162];
            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;
        case 'sicklecell':
          settings.shape = function shapeSiclecell(theta){
            var max = 353;
            var leng = 
[36,38,39,38,39,40,37,38,37,38,39,37,38,38,37,39,37,38,39,37,38,38,37,39,38,40,38,37,39,38,37,39,38,38,38,39,39,38,40,39,40,40,39,40,39,41,40,41,42,42,43,44,42,43,44,45,43,44,45,44,46,45,46,45,47,47,48,49,49,50,49,50,51,52,53,54,53,55,56,58,58,60,63,63,64,65,65,66,67,69,70,71,72,73,74,75,78,79,82,85,88,90,93,95,98,102,106,110,112,116,130,143,353,351,349,348,346,344,342,340,339,336,335,333,330,328,326,324,322,320,318,315,313,312,309,307,304,303,300,297,296,293,291,288,286,285,281,280,278,274,272,270,267,265,264,261,258,257,254,252,249,247,244,242,240,238,235,233,231,228,226,224,222,220,219,216,213,212,210,207,206,204,202,200,199,196,195,193,191,190,188,186,184,182,181,179,178,176,175,174,171,169,168,167,165,164,163,161,160,159,158,157,155,154,152,151,151,150,148,147,146,144,143,142,141,141,139,139,138,136,136,135,133,133,132,132,131,130,129,128,128,127,126,125,125,124,123,122,122,121,122,120,120,119,118,118,118,117,116,116,115,116,115,114,114,113,112,112,111,112,111,111,110,110,109,109,108,108,107,107,107,107,107,107,106,106,106,105,105,105,105,104,104,104,104,103,103,103,103,103,103,102,102,103,102,102,103,102,103,103,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,103,102,102,102,102,103,103,103,103,103,104,104,104,105,105,104,104,105,105,106,106,106,107,107,108,107,107,108,108,108,108,109,109,110,110,110,111,111,112,111,112,113,113,114,114,114,115,116,117,117,117,118,118,119,120,120,121,121,121,123,124,123,125,126,126,127,128,128,128,130,130,131,133,133,134,135,136,136,138,138,139,140,141,143,143,145,146,146,147,149,150,151,152,154,155,156,157,158,160,161,163,164,165,167,168,169,172,173,174,175,176,178,181,181,183,185,187,188,190,192,193,195,198,198,201,204,204,207,209,210,212,214,216,218,220,222,224,227,229,231,233,236,238,240,242,244,247,248,251,253,255,256,260,262,263,266,268,270,272,274,277,279,281,284,285,288,291,292,294,296,298,301,303,305,307,309,311,313,315,317,319,321,323,325,327,329,331,332,334,119,115,110,106,104,92,87,83,82,79,76,75,73,72,70,69,68,67,66,65,64,63,64,62,61,60,58,57,58,55,54,55,53,53,51,50,51,49,50,47,48,46,46,47,45,45,44,45,43,42,43,44,41,41,42,43,40,40,41,42,39,39,40,40,39,40,38,39,40,38,39,37,38,37,38,39,37,38,36,37,38,37,38,39,37,38,39,37,37,36,37,38,36,37,38,36,37,36,37,38,37,38,39,37,38,39,37,38,38,39,40];

            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;

        case 'droplet':
          settings.shape = function shapeDroplet(theta) {
            var max = 1011;
            var leng = [616,615,613,611,608,606,605,602,600,599,596,595,594,591,590,588,587,585,584,583,581,580,578,578,576,575,574,573,572,571,570,570,568,567,567,566,566,565,565,564,563,563,562,562,562,561,561,561,561,561,561,561,561,561,561,561,561,563,563,563,563,563,564,565,566,566,567,567,568,570,571,572,573,574,575,576,577,578,580,581,582,584,586,588,588,590,593,593,596,598,600,602,604,607,609,612,614,617,619,623,625,627,630,634,637,640,644,647,650,654,657,661,665,670,673,678,681,686,690,695,700,705,710,715,720,726,732,737,742,749,755,761,769,775,782,789,796,803,811,819,828,835,844,853,862,871,881,891,901,911,922,934,945,956,970,983,996,1010,998,985,972,959,948,935,925,913,903,892,882,874,863,855,846,837,828,820,813,804,797,790,783,776,769,762,756,750,743,738,732,726,720,715,710,705,701,696,691,686,682,678,674,670,666,662,659,654,651,647,644,640,637,634,631,628,625,622,620,617,615,612,610,608,605,603,601,598,597,595,592,591,589,587,585,584,583,581,580,578,577,576,574,573,572,571,570,569,569,568,567,567,566,564,564,564,564,563,562,562,562,562,561,561,561,561,561,561,561,561,561,562,561,562,563,563,563,563,564,565,565,566,567,567,569,569,570,571,572,573,574,575,576,577,579,579,581,582,584,585,587,588,589,592,593,595,597,598,600,602,604,606,608,610,612,615,617,619,621,623,626,628,630,633,634,637,640,642,645,648,650,653,656,658,661,663,666,669,671,674,677,679,682,684,687,690,693,695,699,701,704,707,711,713,716,720,723,726,729,733,736,740,743,746,750,754,757,761,764,767,771,775,779,782,785,789,793,797,801,804,808,813,816,819,823,827,831,834,838,842,846,850,853,856,860,864,868,871,875,878,882,885,888,891,895,899,902,904,907,911,913,916,920,923,925,927,930,933,936,938,941,943,946,948,949,952,954,957,958,960,962,964,965,968,969,971,972,974,975,977,979,980,982,983,985,986,988,989,990,991,993,994,996,997,998,999,1000,1002,1002,1004,1004,1005,1006,1007,1007,1008,1008,1008,1009,1009,1010,1010,1010,1011,0,1010,1010,1009,1010,1009,1009,1008,1007,1006,1006,1005,1005,1004,1002,1002,1001,999,998,998,996,995,993,992,991,989,988,987,985,984,983,981,980,978,977,975,974,972,970,968,967,964,963,961,959,957,955,953,951,949,946,944,942,939,937,934,932,929,927,924,921,918,915,912,910,906,902,899,896,893,890,886,883,880,876,873,869,865,862,859,855,851,847,843,840,836,832,829,825,821,818,814,810,806,802,799,795,792,788,784,780,776,773,769,766,762,759,754,752,748,745,741,738,734,731,728,725,722,719,715,712,709,706,703,700,697,694,691,689,686,683,680,677,675,672,670,667,665,662,659,656,654,651,649,646,644,641,638,636,634,631,629,627,624,622,620,618];
          
            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;

        case 'brain':
          settings.shape = function shapeBrain(theta) {
            var max = 445;
            var leng = [414,413,411,412,413,414,414,415,414,413,413,411,409,407,406,410,412,413,415,416,417,417,417,416,415,414,412,410,408,404,404,405,406,406,407,407,407,407,408,408,409,408,408,407,406,404,403,399,397,395,393,391,392,393,394,394,394,393,392,391,391,390,389,388,386,385,383,380,376,374,372,371,371,371,372,372,372,372,372,372,373,374,375,376,377,377,377,376,375,374,372,371,369,369,369,370,371,371,372,371,372,371,372,372,372,372,372,372,371,371,370,368,367,365,365,364,364,362,361,360,359,359,357,357,355,354,352,351,351,351,351,351,350,350,349,348,347,346,347,346,347,347,346,347,346,346,345,344,343,343,343,345,347,348,349,349,350,350,349,349,348,347,346,346,347,348,348,348,348,347,346,346,344,344,343,344,346,349,352,355,357,359,360,362,362,363,363,363,363,362,361,360,358,357,360,362,365,366,368,370,370,371,371,372,371,370,370,369,367,369,371,374,375,377,378,378,379,379,379,379,378,377,375,374,374,377,379,382,384,385,387,388,389,388,388,388,387,386,385,384,387,390,392,393,395,395,396,396,396,396,395,394,393,391,392,392,394,395,395,395,395,394,393,392,392,392,392,392,392,391,392,392,392,391,391,390,390,390,390,389,391,393,394,395,395,395,395,395,394,393,392,390,388,387,386,387,389,392,394,395,396,397,397,397,397,396,396,395,392,390,388,385,381,378,377,375,374,371,368,366,361,355,349,322,315,309,304,298,290,288,285,283,280,276,273,269,267,262,258,252,248,245,240,235,231,224,220,217,210,207,202,199,197,192,190,186,182,178,174,170,164,163,164,164,165,165,166,166,167,168,169,169,170,171,171,173,173,174,174,175,175,177,177,177,178,179,179,179,179,180,180,180,181,181,181,182,182,181,182,182,182,182,183,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,183,183,183,183,184,183,183,183,183,183,183,183,185,185,186,186,186,185,186,186,188,188,189,190,190,191,192,192,193,193,194,194,195,197,198,199,203,204,204,205,205,210,215,218,222,226,230,235,238,240,243,246,248,251,254,255,257,259,261,262,264,265,266,267,269,270,271,274,275,279,281,286,292,300,309,438,440,441,442,443,445,445,444,443,440,434,425,411,397,387,378,371,365,361,357,353,351,348,347,345,343,342,341,341,341,341,342,342,342,343,344,345,347,348,349,351,353,356,357,359,360,361,361,362,362,362,361,360,360,359,358,357,357,359,362,366,369,371,374,375,377,378,380,380,380,383,388,392,395,398,401,403,406,409,410,412,414,415,416,416,417,419,419,420,420,420,421,421,421,422,422,423,427,431,434,437,438,440,441,441,441,441,440,438,436,435,434,433,432,431,430,429,428,428,426,426,426,425,424,423,424,424,423,422,421,419,418,416,415];
            return leng[(theta / (2 * Math.PI)) * leng.length | 0] / max;
          };
          break;

        case 'diamond':
        case 'square':
          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+
          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D
          // +0+..+2*PI
          settings.shape = function shapeSquare(theta) {
            var thetaPrime = theta % (2 * Math.PI / 4);
            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));
          };
          break;

        case 'triangle-forward':
          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+
          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29
          // %29%29%2C+t+%3D+0+..+2*PI
          settings.shape = function shapeTriangle(theta) {
            var thetaPrime = theta % (2 * Math.PI / 3);
            return 1 / (Math.cos(thetaPrime) +
                        Math.sqrt(3) * Math.sin(thetaPrime));
          };
          break;

        case 'triangle':
        case 'triangle-upright':
          settings.shape = function shapeTriangle(theta) {
            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);
            return 1 / (Math.cos(thetaPrime) +
                        Math.sqrt(3) * Math.sin(thetaPrime));
          };
          break;

        case 'pentagon':
          settings.shape = function shapePentagon(theta) {
            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);
            return 1 / (Math.cos(thetaPrime) +
                        0.726543 * Math.sin(thetaPrime));
          };
          break;

        case 'star':
          settings.shape = function shapeStar(theta) {
            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);
            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {
              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +
                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));
            } else {
              return 1 / (Math.cos(thetaPrime) +
                          3.07768 * Math.sin(thetaPrime));
            }
          };
          break;
      }
    }

    /* Make sure gridSize is a whole number and is not smaller than 4px */
    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);

    /* shorthand */
    var g = settings.gridSize;
    var maskRectWidth = g - settings.maskGapWidth;

    /* normalize rotation settings */
    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);
    var rotationSteps = Math.abs(Math.floor(settings.rotationSteps));
    var minRotation = Math.min(settings.maxRotation, settings.minRotation);

    /* information/object available to all functions, set when start() */
    var grid, // 2d array containing filling information
      ngx, ngy, // width and height of the grid
      center, // position of the center of the cloud
      maxRadius;

    /* timestamp for measuring each putWord() action */
    var escapeTime;

    /* function for getting the color of the text */
    var getTextColor;
    function random_hsl_color(min, max) {
      return 'hsl(' +
        (Math.random() * 360).toFixed() + ',' +
        (Math.random() * 30 + 70).toFixed() + '%,' +
        (Math.random() * (max - min) + min).toFixed() + '%)';
    }
    switch (settings.color) {
      case 'random-dark':
        getTextColor = function getRandomDarkColor() {
          return random_hsl_color(10, 50);
        };
        break;

      case 'random-light':
        getTextColor = function getRandomLightColor() {
          return random_hsl_color(50, 90);
        };
        break;

      default:
        if (typeof settings.color === 'function') {
          getTextColor = settings.color;
        }
        break;
    }

    /* function for getting the classes of the text */
    var getTextClasses = null;
    if (typeof settings.classes === 'function') {
      getTextClasses = settings.classes;
    }

    /* Interactive */
    var interactive = false;
    var infoGrid = [];
    var hovered;

    var getInfoGridFromMouseTouchEvent =
    function getInfoGridFromMouseTouchEvent(evt) {
      var canvas = evt.currentTarget;
      var rect = canvas.getBoundingClientRect();
      var clientX;
      var clientY;
      /** Detect if touches are available */
      if (evt.touches) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      var eventX = clientX - rect.left;
      var eventY = clientY - rect.top;

      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);
      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);

      return infoGrid[x][y];
    };

    var wordcloudhover = function wordcloudhover(evt) {
      var info = getInfoGridFromMouseTouchEvent(evt);

      if (hovered === info) {
        return;
      }

      hovered = info;
      if (!info) {
        settings.hover(undefined, undefined, evt);

        return;
      }

      settings.hover(info.item, info.dimension, evt);

    };

    var wordcloudclick = function wordcloudclick(evt) {
      var info = getInfoGridFromMouseTouchEvent(evt);
      if (!info) {
        return;
      }

      settings.click(info.item, info.dimension, evt);
      evt.preventDefault();
    };

    /* Get points on the grid for a given radius away from the center */
    var pointsAtRadius = [];
    var getPointsAtRadius = function getPointsAtRadius(radius) {
      if (pointsAtRadius[radius]) {
        return pointsAtRadius[radius];
      }

      // Look for these number of points on each radius
      var T = radius * 8;

      // Getting all the points at this radius
      var t = T;
      var points = [];

      if (radius === 0) {
        points.push([center[0], center[1], 0]);
      }

      while (t--) {
        // distort the radius to put the cloud in shape
        var rx = 1;
        if (settings.shape !== 'circle') {
          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1
        }

        // Push [x, y, t]; t is used solely for getTextColor()
        points.push([
          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),
          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *
            settings.ellipticity,
          t / T * 2 * Math.PI]);
      }

      pointsAtRadius[radius] = points;
      return points;
    };

    /* Return true if we had spent too much time */
    var exceedTime = function exceedTime() {
      return ((settings.abortThreshold > 0) &&
        ((new Date()).getTime() - escapeTime > settings.abortThreshold));
    };

    /* Get the deg of rotation according to settings, and luck. */
    var getRotateDeg = function getRotateDeg() {
      if (settings.rotateRatio === 0) {
        return 0;
      }

      if (Math.random() > settings.rotateRatio) {
        return 0;
      }

      if (rotationRange === 0) {
        return minRotation;
      }
      if (rotationSteps > 0) {
        // Min rotation + zero or more steps * span of one step
        return minRotation +
          Math.floor(Math.random() * rotationSteps) *
          rotationRange / (rotationSteps)
      } else {
        return minRotation + Math.random() * rotationRange
      }
    };

    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {
      // calculate the acutal font size
      // fontSize === 0 means weightFactor function wants the text skipped,
      // and size < minSize means we cannot draw the text.
      var debug = false;
      var fontSize = settings.weightFactor(weight);
      if (fontSize <= settings.minSize) {
        return false;
      }

      // Scale factor here is to make sure fillText is not limited by
      // the minium font size set by browser.
      // It will always be 1 or 2n.
      var mu = 1;
      if (fontSize < minFontSize) {
        mu = (function calculateScaleFactor() {
          var mu = 2;
          while (mu * fontSize < minFontSize) {
            mu += 2;
          }
          return mu;
        })();
      }

      var fcanvas = document.createElement('canvas');
      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });

      fctx.font = settings.fontWeight + ' ' +
        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;

      // Estimate the dimension of the text with measureText().
      var fw = fctx.measureText(word).width / mu;
      var fh = Math.max(fontSize * mu,
                        fctx.measureText('m').width,
                        fctx.measureText('\uFF37').width) / mu;

      // Create a boundary box that is larger than our estimates,
      // so text don't get cut of (it sill might)
      var boxWidth = fw + fh * 2;
      var boxHeight = fh * 3;
      var fgw = Math.ceil(boxWidth / g);
      var fgh = Math.ceil(boxHeight / g);
      boxWidth = fgw * g;
      boxHeight = fgh * g;

      // Calculate the proper offsets to make the text centered at
      // the preferred position.

      // This is simply half of the width.
      var fillTextOffsetX = - fw / 2;
      // Instead of moving the box to the exact middle of the preferred
      // position, for Y-offset we move 0.4 instead, so Latin alphabets look
      // vertical centered.
      var fillTextOffsetY = - fh * 0.4;

      // Calculate the actual dimension of the canvas, considering the rotation.
      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +
                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);
      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +
                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);
      var width = cgw * g;
      var height = cgh * g;

      fcanvas.setAttribute('width', width);
      fcanvas.setAttribute('height', height);

      if (debug) {
        // Attach fcanvas to the DOM
        document.body.appendChild(fcanvas);
        // Save it's state so that we could restore and draw the grid correctly.
        fctx.save();
      }

      // Scale the canvas with |mu|.
      fctx.scale(1 / mu, 1 / mu);
      fctx.translate(width * mu / 2, height * mu / 2);
      fctx.rotate(- rotateDeg);

      // Once the width/height is set, ctx info will be reset.
      // Set it again here.
      fctx.font = settings.fontWeight + ' ' +
        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;

      // Fill the text into the fcanvas.
      // XXX: We cannot because textBaseline = 'top' here because
      // Firefox and Chrome uses different default line-height for canvas.
      // Please read https://bugzil.la/737852#c6.
      // Here, we use textBaseline = 'middle' and draw the text at exactly
      // 0.5 * fontSize lower.
      fctx.fillStyle = '#000';
      fctx.textBaseline = 'middle';
      fctx.fillText(word, fillTextOffsetX * mu,
                    (fillTextOffsetY + fontSize * 0.5) * mu);

      // Get the pixels of the text
      var imageData = fctx.getImageData(0, 0, width, height).data;

      if (exceedTime()) {
        return false;
      }

      if (debug) {
        // Draw the box of the original estimation
        fctx.strokeRect(fillTextOffsetX * mu,
                        fillTextOffsetY, fw * mu, fh * mu);
        fctx.restore();
      }

      // Read the pixels and save the information to the occupied array
      var occupied = [];
      var gx = cgw, gy, x, y;
      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];
      while (gx--) {
        gy = cgh;
        while (gy--) {
          y = g;
          singleGridLoop: {
            while (y--) {
              x = g;
              while (x--) {
                if (imageData[((gy * g + y) * width +
                               (gx * g + x)) * 4 + 3]) {
                  occupied.push([gx, gy]);

                  if (gx < bounds[3]) {
                    bounds[3] = gx;
                  }
                  if (gx > bounds[1]) {
                    bounds[1] = gx;
                  }
                  if (gy < bounds[0]) {
                    bounds[0] = gy;
                  }
                  if (gy > bounds[2]) {
                    bounds[2] = gy;
                  }

                  if (debug) {
                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);
                  }
                  break singleGridLoop;
                }
              }
            }
            if (debug) {
              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);
            }
          }
        }
      }

      if (debug) {
        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        fctx.fillRect(bounds[3] * g,
                      bounds[0] * g,
                      (bounds[1] - bounds[3] + 1) * g,
                      (bounds[2] - bounds[0] + 1) * g);
      }

      // Return information needed to create the text on the real canvas
      return {
        mu: mu,
        occupied: occupied,
        bounds: bounds,
        gw: cgw,
        gh: cgh,
        fillTextOffsetX: fillTextOffsetX,
        fillTextOffsetY: fillTextOffsetY,
        fillTextWidth: fw,
        fillTextHeight: fh,
        fontSize: fontSize
      };
    };

    /* Determine if there is room available in the given dimension */
    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {
      // Go through the occupied points,
      // return false if the space is not available.
      var i = occupied.length;
      while (i--) {
        var px = gx + occupied[i][0];
        var py = gy + occupied[i][1];

        if (px >= ngx || py >= ngy || px < 0 || py < 0 || !grid[px][py]) {
          return false;
        }
      }
      return true;
    };

    /* Actually draw the text on the grid */
    var drawText = function drawText(gx, gy, info, word, weight,
                                     distance, theta, rotateDeg, attributes) {

      var fontSize = info.fontSize;
      var color;
      if (getTextColor) {
        color = getTextColor(word, weight, fontSize, distance, theta);
      } else if (settings.color instanceof Array) {
        color = settings.color.shift() || 'black'; // pass a array in setting, default 'black'
      } else {
        color = settings.color;
      }

      var classes;
      if (getTextClasses) {
        classes = getTextClasses(word, weight, fontSize, distance, theta);
      } else {
        classes = settings.classes;
      }

      var dimension;
      var bounds = info.bounds;
      dimension = {
        x: (gx + bounds[3]) * g,
        y: (gy + bounds[0]) * g,
        w: (bounds[1] - bounds[3] + 1) * g,
        h: (bounds[2] - bounds[0] + 1) * g
      };

      elements.forEach(function(el) {
        if (el.getContext) {
          var ctx = el.getContext('2d');
          var mu = info.mu;

          // Save the current state before messing it
          ctx.save();
          ctx.scale(1 / mu, 1 / mu);

          ctx.font = settings.fontWeight + ' ' +
                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;
          ctx.fillStyle = color;

          // Translate the canvas position to the origin coordinate of where
          // the text should be put.
          ctx.translate((gx + info.gw / 2) * g * mu,
                        (gy + info.gh / 2) * g * mu);

          if (rotateDeg !== 0) {
            ctx.rotate(- rotateDeg);
          }

          // Finally, fill the text.

          // XXX: We cannot because textBaseline = 'top' here because
          // Firefox and Chrome uses different default line-height for canvas.
          // Please read https://bugzil.la/737852#c6.
          // Here, we use textBaseline = 'middle' and draw the text at exactly
          // 0.5 * fontSize lower.
          ctx.textBaseline = 'middle';
          ctx.fillText(word, info.fillTextOffsetX * mu,
                             (info.fillTextOffsetY + fontSize * 0.5) * mu);

          // The below box is always matches how <span>s are positioned
          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,
            info.fillTextWidth, info.fillTextHeight); */

          // Restore the state.
          ctx.restore();
        } else {
          // drawText on DIV element
          var span = document.createElement('span');
          var transformRule = '';
          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';
          if (info.mu !== 1) {
            transformRule +=
              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +
              'scale(' + (1 / info.mu) + ')';
          }
          var styleRules = {
            'position': 'absolute',
            'display': 'block',
            'font': settings.fontWeight + ' ' +
                    (fontSize * info.mu) + 'px ' + settings.fontFamily,
            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',
            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',
            'width': info.fillTextWidth + 'px',
            'height': info.fillTextHeight + 'px',
            'lineHeight': fontSize + 'px',
            'whiteSpace': 'nowrap',
            'transform': transformRule,
            'webkitTransform': transformRule,
            'msTransform': transformRule,
            'transformOrigin': '50% 40%',
            'webkitTransformOrigin': '50% 40%',
            'msTransformOrigin': '50% 40%'
          };
          if (color) {
            styleRules.color = color;
          }
          span.textContent = word;
          for (var cssProp in styleRules) {
            span.style[cssProp] = styleRules[cssProp];
          }
          if (attributes) {
            for (var attribute in attributes) {
              span.setAttribute(attribute, attributes[attribute]);
            }
          }
          if (classes) {
            span.className += classes;
          }
          el.appendChild(span);
        }
      });
    };

    /* Help function to updateGrid */
    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {
      if (x >= ngx || y >= ngy || x < 0 || y < 0) {
        return;
      }

      grid[x][y] = false;

      if (drawMask) {
        var ctx = elements[0].getContext('2d');
        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);
      }

      if (interactive) {
        infoGrid[x][y] = { item: item, dimension: dimension };
      }
    };

    /* Update the filling information of the given space with occupied points.
       Draw the mask on the canvas if necessary. */
    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {
      var occupied = info.occupied;
      var drawMask = settings.drawMask;
      var ctx;
      if (drawMask) {
        ctx = elements[0].getContext('2d');
        ctx.save();
        ctx.fillStyle = settings.maskColor;
      }

      var dimension;
      if (interactive) {
        var bounds = info.bounds;
        dimension = {
          x: (gx + bounds[3]) * g,
          y: (gy + bounds[0]) * g,
          w: (bounds[1] - bounds[3] + 1) * g,
          h: (bounds[2] - bounds[0] + 1) * g
        };
      }

      var i = occupied.length;
      while (i--) {
        fillGridAt(gx + occupied[i][0], gy + occupied[i][1],
                   drawMask, dimension, item);
      }

      if (drawMask) {
        ctx.restore();
      }
    };

    /* putWord() processes each item on the list,
       calculate it's size and determine it's position, and actually
       put it on the canvas. */
    var putWord = function putWord(item) {
      var word, weight, attributes;
      if (Array.isArray(item)) {
        word = item[0];
        weight = item[1];
      } else {
        word = item.word;
        weight = item.weight;
        attributes = item.attributes;
      }
      var rotateDeg = getRotateDeg();

      // get info needed to put the text onto the canvas
      var info = getTextInfo(word, weight, rotateDeg);

      // not getting the info means we shouldn't be drawing this one.
      if (!info) {
        return false;
      }

      if (exceedTime()) {
        return false;
      }

      // Skip the loop if we have already know the bounding box of
      // word is larger than the canvas.
      var bounds = info.bounds;
      if ((bounds[1] - bounds[3] + 1) > ngx ||
        (bounds[2] - bounds[0] + 1) > ngy) {
        return false;
      }

      // Determine the position to put the text by
      // start looking for the nearest points
      var r = maxRadius + 1;

      var tryToPutWordAtPoint = function(gxy) {
        var gx = Math.floor(gxy[0] - info.gw / 2);
        var gy = Math.floor(gxy[1] - info.gh / 2);
        var gw = info.gw;
        var gh = info.gh;

        // If we cannot fit the text at this position, return false
        // and go to the next position.
        if (!canFitText(gx, gy, gw, gh, info.occupied)) {
          return false;
        }

        // Actually put the text on the canvas
        drawText(gx, gy, info, word, weight,
                 (maxRadius - r), gxy[2], rotateDeg, attributes);

        // Mark the spaces on the grid as filled
        updateGrid(gx, gy, gw, gh, info, item);

        // Return true so some() will stop and also return true.
        return true;
      };

      while (r--) {
        var points = getPointsAtRadius(maxRadius - r);

        if (settings.shuffle) {
          points = [].concat(points);
          shuffleArray(points);
        }

        // Try to fit the words by looking at each point.
        // array.some() will stop and return true
        // when putWordAtPoint() returns true.
        // If all the points returns false, array.some() returns false.
        var drawn = points.some(tryToPutWordAtPoint);

        if (drawn) {
          // leave putWord() and return true
          return true;
        }
      }
      // we tried all distances but text won't fit, return false
      return false;
    };

    /* Send DOM event to all elements. Will stop sending event and return
       if the previous one is canceled (for cancelable events). */
    var sendEvent = function sendEvent(type, cancelable, detail) {
      if (cancelable) {
        return !elements.some(function(el) {
          var evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(type, true, cancelable, detail || {});
          return !el.dispatchEvent(evt);
        }, this);
      } else {
        elements.forEach(function(el) {
          var evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(type, true, cancelable, detail || {});
          el.dispatchEvent(evt);
        }, this);
      }
    };

    /* Start drawing on a canvas */
    var start = function start() {
      // For dimensions, clearCanvas etc.,
      // we only care about the first element.
      var canvas = elements[0];

      if (canvas.getContext) {
        ngx = Math.floor(canvas.width / g);
        ngy = Math.floor(canvas.height / g);
      } else {
        var rect = canvas.getBoundingClientRect();
        ngx = Math.floor(rect.width / g);
        ngy = Math.floor(rect.height / g);
      }

      // Sending a wordcloudstart event which cause the previous loop to stop.
      // Do nothing if the event is canceled.
      if (!sendEvent('wordcloudstart', true)) {
        return;
      }

      // Determine the center of the word cloud
      center = (settings.origin) ?
        [settings.origin[0]/g, settings.origin[1]/g] :
        [ngx / 2, ngy / 2];

      // Maxium radius to look for space
      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));

      /* Clear the canvas only if the clearCanvas is set,
         if not, update the grid to the current canvas state */
      grid = [];

      var gx, gy, i;
      if (!canvas.getContext || settings.clearCanvas) {
        elements.forEach(function(el) {
          if (el.getContext) {
            var ctx = el.getContext('2d');
            ctx.fillStyle = settings.backgroundColor;
            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));
            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));
          } else {
            el.textContent = '';
            el.style.backgroundColor = settings.backgroundColor;
          }
        });

        /* fill the grid with empty state */
        gx = ngx;
        while (gx--) {
          grid[gx] = [];
          gy = ngy;
          while (gy--) {
            grid[gx][gy] = true;
          }
        }
      } else {
        /* Determine bgPixel by creating
           another canvas and fill the specified background color. */
        var bctx = document.createElement('canvas').getContext('2d');

        bctx.fillStyle = settings.backgroundColor;
        bctx.fillRect(0, 0, 1, 1);
        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;

        /* Read back the pixels of the canvas we got to tell which part of the
           canvas is empty.
           (no clearCanvas only works with a canvas, not divs) */
        var imageData =
          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;

        gx = ngx;
        var x, y;
        while (gx--) {
          grid[gx] = [];
          gy = ngy;
          while (gy--) {
            y = g;
            singleGridLoop: while (y--) {
              x = g;
              while (x--) {
                i = 4;
                while (i--) {
                  if (imageData[((gy * g + y) * ngx * g +
                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {
                    grid[gx][gy] = false;
                    break singleGridLoop;
                  }
                }
              }
            }
            if (grid[gx][gy] !== false) {
              grid[gx][gy] = true;
            }
          }
        }

        imageData = bctx = bgPixel = undefined;
      }

      // fill the infoGrid with empty state if we need it
      if (settings.hover || settings.click) {

        interactive = true;

        /* fill the grid with empty state */
        gx = ngx + 1;
        while (gx--) {
          infoGrid[gx] = [];
        }

        if (settings.hover) {
          canvas.addEventListener('mousemove', wordcloudhover);
        }

        if (settings.click) {
          canvas.addEventListener('click', wordcloudclick);
          canvas.addEventListener('touchstart', wordcloudclick);
          canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
          });
          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';
        }

        canvas.addEventListener('wordcloudstart', function stopInteraction() {
          canvas.removeEventListener('wordcloudstart', stopInteraction);

          canvas.removeEventListener('mousemove', wordcloudhover);
          canvas.removeEventListener('click', wordcloudclick);
          hovered = undefined;
        });
      }

      i = 0;
      var loopingFunction, stoppingFunction;
      if (settings.wait !== 0) {
        loopingFunction = window.setTimeout;
        stoppingFunction = window.clearTimeout;
      } else {
        loopingFunction = window.setImmediate;
        stoppingFunction = window.clearImmediate;
      }

      var addEventListener = function addEventListener(type, listener) {
        elements.forEach(function(el) {
          el.addEventListener(type, listener);
        }, this);
      };

      var removeEventListener = function removeEventListener(type, listener) {
        elements.forEach(function(el) {
          el.removeEventListener(type, listener);
        }, this);
      };

      var anotherWordCloudStart = function anotherWordCloudStart() {
        removeEventListener('wordcloudstart', anotherWordCloudStart);
        stoppingFunction(timer);
      };

      addEventListener('wordcloudstart', anotherWordCloudStart);

      var timer = loopingFunction(function loop() {
        if (i >= settings.list.length) {
          stoppingFunction(timer);
          sendEvent('wordcloudstop', false);
          removeEventListener('wordcloudstart', anotherWordCloudStart);

          return;
        }
        escapeTime = (new Date()).getTime();
        var drawn = putWord(settings.list[i]);
        var canceled = !sendEvent('wordclouddrawn', true, {
          item: settings.list[i], drawn: drawn });
        if (exceedTime() || canceled) {
          stoppingFunction(timer);
          settings.abort();
          sendEvent('wordcloudabort', false);
          sendEvent('wordcloudstop', false);
          removeEventListener('wordcloudstart', anotherWordCloudStart);
          return;
        }
        i++;
        timer = loopingFunction(loop, settings.wait);
      }, settings.wait);
    };

    // All set, start the drawing
    start();
  };

  WordCloud.isSupported = isSupported;
  WordCloud.minFontSize = minFontSize;

  // Expose the library as an AMD module
  if (typeof define === 'function' && define.amd) {
    define('wordcloud', [], function() { return WordCloud; });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = WordCloud;
  } else {
    global.WordCloud = WordCloud;
  }

})(this); //jshint ignore:line
